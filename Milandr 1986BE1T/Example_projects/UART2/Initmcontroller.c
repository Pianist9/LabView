#include "Initmcontroller.h"
//Tx - передатчик Rx - приемник

void INITZ_CLKPORT (void)
{   ///----------------------------------Настройка тактовой частоты---------------------------------------------------------------|
	
	  ///----------------------------------Тактирование портов----------------------------------------------------------------------|
	  MDR_RST_CLK->PER_CLOCK  |= (1<<4);   //тактирование RCT_CLC
		//-----------------------------------ТАКТОВАЯ ЧАСТОТА -------------------------------------------
	  MDR_RST_CLK->PLL_CONTROL = 0x804; 	   //Регистр управления блоками умножения частоты  PPLCPUo = PPLCPUi*(PLLCPUMUL+1) 104/(404 max speed 16*[4+1]=80  804 16*[8+1]=144) ;
  	MDR_RST_CLK->HS_CONTROL  = 0x5;        //Регистр управления высокочастотным генератором и осциллятором (осцилятор HSE on HSE2 on)
		MDR_RST_CLK->CPU_CLOCK   = 0x106;      //Регистр управления тактовой частотой процессорного ядра (106- PLL_control ON | 102 PPLCPU OFF) HSE 16 мгц

    //while ((MDR_RST_CLK->CLOCK_STATUS & 0x1)== 0);  // HSE RDY2
    //while ((MDR_RST_CLK->CLOCK_STATUS & 0x2)== 0);  // HSE RDY
    //while ((MDR_RST_CLK->CLOCK_STATUS & 0x4)== 0);  // PLL CPU RDY
	  //while ((MDR_RST_CLK->CLOCK_STATUS & 0x8)== 0);  // PLL USB RDY
}		//____________________________________________________________________________________________________________________________|



void INITZ_TMR(void)
{   ///----------------------------------Настройка таймера------------------------------------------------------------------------|
	  MDR_RST_CLK->PER_CLOCK |=(1<<14);  						//тактирование TIMER1
		MDR_RST_CLK->TIM_CLOCK  = 0x7000000;  				//Регистр управления тактовой частотой TIMER
		MDR_RST_CLK->TIM_CLOCK  = 0x07000000;						
			
		//MDR_TIMER1->CNT = 0;                        //Значение основного счетчика таймера
		MDR_TIMER1->PSG = 0x00000000 ;                //Значение предварительного делителя счетчика . Основной счетчик считает на частоте: CLK = TIM_CLK/(PSG+1)
		MDR_TIMER1->ARR = 4000;                       //Основание счета основного счетчика 
		MDR_TIMER1->IE  = 0x00000002;                 //разрешаем прерывание по совпадению CNT и ARR	
		NVIC_EnableIRQ(TIMER1_IRQn);                  //Разрешение от таймера в целом
		//Включаем таймер
}   //____________________________________________________________________________________________________________________________|



void INITZ_UART1(void)
{   ///----------------------------------Настройка UART1--------------------------------------------------------------------------|
	
	  MDR_RST_CLK->PER_CLOCK  |= (1<<6);        //тактирование UART2
	  MDR_RST_CLK->UART_CLOCK |= (1<<24);       //Регистр управления тактовой частотой UART 
	  MDR_RST_CLK->UART_CLOCK |= (101<<0);      //101--32 //MDR_RST_CLK->UART_CLOCK = 0x3000404;     
		MDR_UART1->IBRD  = 0x0002;                //Целая часть коэффициента деления частоты для формирования тактового сигнала передачи данных. После сброса устанавливается в 0
		MDR_UART1->FBRD  = 0x001C;                //дробная 4/(16*115200) =2,17    2 | 0,17   (0,17*64)+0,5 = 11 =0X0B      0x1C=28
	  MDR_UART1->LCR_H = 0x060;                 //Длина слова – количество передаваемых или принимаемых информационных бит в кадре:
		MDR_UART1->CR    = 0x301;                 //Регистр управления /разрешение приема передачи и работы (301)
		MDR_UART1->IMSC  = 0x30;                  //TxRx_interrupt_enable  (1<<4)(1<<5)
	  MDR_UART1->ICR   = 0x30;                  //TxRx_interrupt_flag clear (1<<4)(1<<5)
	  MDR_UART1->DMACR = 0x00;
		NVIC_EnableIRQ(UART1_IRQn);	
}   //____________________________________________________________________________________________________________________________|

	
	
void INITZ_UART2(void)
{   ///----------------------------------Настройка UART2--------------------------------------------------------------------------|
	
	  MDR_RST_CLK->PER_CLOCK  |=(1<<7);      //тактирование UART2
	  MDR_RST_CLK->UART_CLOCK |=(1<<25);    //Регистр управления тактовой частотой UART  
	  MDR_RST_CLK->UART_CLOCK |= (101<<8);
		MDR_UART2->IBRD  = 0x0002;            //Целая часть коэффициента деления частоты для формирования тактового сигнала передачи данных. После сброса устанавливается в 0
		MDR_UART2->FBRD  = 0x001C;            //дробная 4/(16*115200) =2,17    2 | 0,17   (0,17*64)+0,5 = 11 =0X0B
	  MDR_UART2->LCR_H = 0x060;             //Длина слова – количество передаваемых или принимаемых информационных бит в кадре: 60
		MDR_UART2->CR    = 0x301;             //Регистр управления /разрешение приема передачи и работы (301)
		MDR_UART2->IMSC  = 0x30;              //TxRx_interrupt_enable  (1<<4)(1<<5)
	  MDR_UART2->ICR   = 0x30;              //TxRx_interrupt_flag clear (1<<4)(1<<5)
	  MDR_UART2->DMACR = 0x00;              
		NVIC_EnableIRQ(UART2_IRQn);	          
}   //____________________________________________________________________________________________________________________________|


void INITZ_SPI1 (void)
{   ///----------------------------------Настройка SPI1---------------------------------------------------------------------------|
		MDR_RST_CLK->PER_CLOCK |=(1<<8);	  //тактирование
	  MDR_RST_CLK->SSP_CLOCK |=(1<<24);   //Разрешение тактовой частоты /делитель  /-
		MDR_SSP1->CR0           = 0x07;     // ПРОТОКОЛ Motorola, Размер слова данных: 1 байт
		MDR_SSP1->CR1  					= 0x02;     // Разрешение работы приемопередатчика:( 0x02 ведущий)( 0xE ведомый Tx off [полу дуплекс] 0x06 дуплекс)
		MDR_SSP1->CPSR 					= 0x02;     // Коэффициент деления тактовой частоты.(0x2 Ведущий)(0x12 Ведомый)
		MDR_SSP1->IMSC 					= 0x00;
	  //NVIC_EnableIRQ(SSP1_IRQn);        //прерывания
}	  //____________________________________________________________________________________________________________________________|


void INITZ_SPI2 (void)
{   ///----------------------------------Настройка SPI2---------------------------------------------------------------------------|
		MDR_RST_CLK->PER_CLOCK |=(1<<20);	  // тактирование
	  MDR_RST_CLK->SSP_CLOCK |=(1<<25);   // Разрешение тактовой частоты /делитель  /-
		MDR_SSP2->CR0  					= 0x07;     // ПРОТОКОЛ Motorola, Размер слова данных: 1 байт
		MDR_SSP2->CR1  					= 0x02;     // Разрешение работы приемопередатчика: (0x02 ведущий)( 0xE ведомый Tx off [полу дуплекс] 0x06 дуплекс)
		MDR_SSP2->CPSR 					= 0x02;     // Коэффициент деления тактовой частоты.(0x2 Ведущий)(0x12 Ведомый)
		MDR_SSP2->IMSC 					= 0x0C;     // TxRx_interrupt_enable
	  NVIC_EnableIRQ(SSP2_IRQn);          // прерывания on
}	  //____________________________________________________________________________________________________________________________|


/*void INITZ_SPI3 (void)
{   ///----------------------------------Настройка SPI2---------------------------------------------------------------------------|
		MDR_RST_CLK->PER_CLOCK |=(1<<31);	  // тактирование
	  MDR_RST_CLK->SSP_CLOCK |=(1<<26);   // Разрешение тактовой частоты /делитель  /-
		MDR_SSP2->CR0  					= 0x07;     // ПРОТОКОЛ Motorola, Размер слова данных: 1 байт
		MDR_SSP2->CR1  					= 0x02;     // Разрешение работы приемопередатчика: (0x02 ведущий)( 0xE ведомый Tx off [полу дуплекс] 0x06 дуплекс)
		MDR_SSP2->CPSR 					= 0x02;     // Коэффициент деления тактовой частоты.(0x2 Ведущий)(0x12 Ведомый)
		MDR_SSP2->IMSC 					= 0x0C;     // TxRx_interrupt_enable
	  NVIC_EnableIRQ(SSP2_IRQn);          // прерывания on
}	  //____________________________________________________________________________________________________________________________|*/


void INIPORTA(void)
{   ///---------------------------------------  Настройка ПОРТА A  (аннотация)  --------------------------------------------------|
	
	  MDR_RST_CLK->PER_CLOCK |=(1<<21);  //тактирование PORTC
		//___________________________________ИНИЦИАЛИЗАЦИЯ ПОРТА_______________________________________________________________________
	  MDR_PORTA->OE     = 0xFFFF;					//Режим работы контроллера. Направление передачи данных на выводах порта:1 – выход;0 – вход
		MDR_PORTA->FUNC   = 0x0000;         //Режим работы вывода порта:00 – порт; 01 – основная функция; 10 – альтернативная функция UART
		MDR_PORTA->ANALOG = 0xffff;				  //Режим работы контроллера:0 – аналоговый; 1 – цифровой
		MDR_PORTA->PD     = 0x0000;         /*SHM[15:0]Режим работы входа:
																				0 – триггер Шмитта выключен гистерезис 200 мВ;
																				1 – триггер Шмитта включен гистерезис 400 мВ
																					PD[15:0]Режим работы выхода:
																				0 – управляемый драйвер;
																				1 – открытый сток
	*/
		MDR_PORTA->PWR    = 0xFFFFFFFF;     /*55555555;        Режим работы вывода порта:
                                        00 – зарезервировано (передатчик отключен)
																				01 – медленный фронт ( порядка 100 нс)
																				10 – быстрый фронт ( порядка 20 нс)
																				11 – максимально быстрый фронт ( порядка 10 нс)*/
		MDR_PORTA->GFEN   = 0x00;           //Режим работы входного фильтра:0 – фильтр выключен;1 – фильтр включен (фильтрация импульсов до 10 нс)
}	  //____________________________________________________________________________________________________________________________|


//MDR_PORTA->RXTX ^= 0x2000;
//MDR_PORTA->RXTX ^= 0x0200;
//MDR_PORTA->RXTX ^= 0x04;
//MDR_PORTA->RXTX ^= 0x02;
//MDR_PORTA->RXTX ^= 0x01;     


void INIPORTB(void)
{	  ///----------------------------------Настройка ПОРТА B -----------------------------------------------------------------------|
	
	  MDR_RST_CLK->PER_CLOCK  |=(1<<22);    //тактирование PORTB
		MDR_PORTB->OE     = 0xFFFF;             //xxxxxx10
		MDR_PORTB->FUNC   = 0x0000;      //UART2
		MDR_PORTB->ANALOG = 0xFFFF;      //
		MDR_PORTB->PD     = 0x0000;          //драйвер/сток
		MDR_PORTB->PWR    = 0xFFFF;      //Макс фронт
		MDR_PORTB->GFEN   = 0x0000;            //фильтрация импульсов до 10 нс
}   //____________________________________________________________________________________________________________________________|

void INIPORTC(void)
{	  ///----------------------------------Настройка ПОРТА C UART-------------------------------------------------------------------|
    MDR_RST_CLK->PER_CLOCK  |=(1<<23);    //тактирование PORTC
		//MDR_PORTC->OE         = 0x0308;          //xxxxxx10
   MDR_PORTC->OE           = 0xFFFF;
		//MDR_PORTC->FUNC       = 0x0140;          
   MDR_PORTC->FUNC         = 0x0000;          
		MDR_PORTC->ANALOG       = 0xFFFF;          //
		MDR_PORTC->PD           = 0x0000;          //драйвер/сток
		MDR_PORTC->PWR          = 0xFFFF;          //Макс фронт
		MDR_PORTC->GFEN         = 0x0000;          //фильтрация импульсов до 10 нс

	
	
	
}   //____________________________________________________________________________________________________________________________|

//MDR_PORTC->RXTX ^= 0x0300;
//MDR_PORTC->RXTX ^= 0x0100;

void INIPORTD(void)
{	  ///----------------------------------Настройка ПОРТА D ножка PD0 PD1   UART2--------------------------------------------------|
	
	  MDR_RST_CLK->PER_CLOCK |=(1<<24);    //тактирование PORTD
		MDR_PORTD->OE     = 0xFFFF;            //xxxxxx10
		MDR_PORTD->FUNC   = 0x0000;            //UART2
		MDR_PORTD->ANALOG = 0xFFFF;            //
		MDR_PORTD->PD     = 0x0000;            //драйвер/сток
		MDR_PORTD->PWR    = 0xFFFF;            //Макс фронт
		MDR_PORTD->GFEN   = 0x0000;            //фильтрация импульсов до 10 нс
}   //____________________________________________________________________________________________________________________________|

void INIPORTE(void)
{	  ///----------------------------------Настройка ПОРТА B -----------------------------------------------------------------------|
	
	  MDR_RST_CLK->PER_CLOCK |=(1<<25);    //тактирование PORTD
		MDR_PORTE->OE     = 0xFFFF;             //xxxxxx10
		MDR_PORTE->FUNC   = 0x0000;      //UART2
		MDR_PORTE->ANALOG = 0xFFFF;      //
		MDR_PORTE->PD     = 0x0000;          //драйвер/сток
		MDR_PORTE->PWR    = 0xFFFF;      //Макс фронт
		MDR_PORTE->GFEN   = 0x0000;            //фильтрация импульсов до 10 нс
}   //____________________________________________________________________________________________________________________________|

void INIPORTF (void)
{	  ///----------------------------------Настройка ПОРТА F ножка PF0 PF1   UART2--------------------------------------------------|
	
	  MDR_RST_CLK->PER_CLOCK |=(1<<29);     //тактирование PORTF
		MDR_PORTF->OE     = 0xFFFF;              //xxxxxx10
		MDR_PORTF->FUNC   = 0x0000;       //UART1
		MDR_PORTF->ANALOG = 0xFFFF;       //
		MDR_PORTF->PD     = 0x0000;           //драйвер/сток
		MDR_PORTF->PWR    = 0xFFFF;       //Макс фронт
		MDR_PORTF->GFEN   = 0x0000;             //фильтрация импульсов до 10 нс
}   //____________________________________________________________________________________________________________________________|









/*void ACP(void)
{
	
MDR_RST_CLK->ADC_MCO_CLOCK = 0x2022;     // установка  частоты АЦП
MDR_RST_CLK->PER_CLOCK    |= (1<<17);
	
MDR_ADC->ADC1_CFG      = 0x00;
MDR_ADC->ADC2_CFG      = 0x00;
MDR_ADC->	ADC1_H_LEVEL = 0x00;
MDR_ADC->	ADC2_H_LEVEL = 0x00;
MDR_ADC->	ADC1_L_LEVEL = 0x00;
MDR_ADC->	ADC2_L_LEVEL = 0x00;
MDR_ADC->	ADC1_RESULT  = 0x00;
MDR_ADC->	ADC2_RESULT  = 0x00;
MDR_ADC->ADC1_STATUS   = 0x00;
MDR_ADC->ADC2_STATUS   = 0x00;	
MDR_ADC->ADC1_CHSEL    = 0x00;
MDR_ADC->ADC2_CHSEL    = 0x00;
}*/
















